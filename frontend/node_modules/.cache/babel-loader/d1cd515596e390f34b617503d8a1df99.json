{"ast":null,"code":"var ber = require('asn1').Ber;\n\nvar _ = require('../utils')._;\n\nvar utils = require('../utils');\n\nvar PRIVATE_OPENING_BOUNDARY = '-----BEGIN RSA PRIVATE KEY-----';\nvar PRIVATE_CLOSING_BOUNDARY = '-----END RSA PRIVATE KEY-----';\nvar PUBLIC_OPENING_BOUNDARY = '-----BEGIN RSA PUBLIC KEY-----';\nvar PUBLIC_CLOSING_BOUNDARY = '-----END RSA PUBLIC KEY-----';\nmodule.exports = {\n  privateExport: function privateExport(key, options) {\n    options = options || {};\n    var n = key.n.toBuffer();\n    var d = key.d.toBuffer();\n    var p = key.p.toBuffer();\n    var q = key.q.toBuffer();\n    var dmp1 = key.dmp1.toBuffer();\n    var dmq1 = key.dmq1.toBuffer();\n    var coeff = key.coeff.toBuffer();\n    var length = n.length + d.length + p.length + q.length + dmp1.length + dmq1.length + coeff.length + 512; // magic\n\n    var writer = new ber.Writer({\n      size: length\n    });\n    writer.startSequence();\n    writer.writeInt(0);\n    writer.writeBuffer(n, 2);\n    writer.writeInt(key.e);\n    writer.writeBuffer(d, 2);\n    writer.writeBuffer(p, 2);\n    writer.writeBuffer(q, 2);\n    writer.writeBuffer(dmp1, 2);\n    writer.writeBuffer(dmq1, 2);\n    writer.writeBuffer(coeff, 2);\n    writer.endSequence();\n\n    if (options.type === 'der') {\n      return writer.buffer;\n    } else {\n      return PRIVATE_OPENING_BOUNDARY + '\\n' + utils.linebrk(writer.buffer.toString('base64'), 64) + '\\n' + PRIVATE_CLOSING_BOUNDARY;\n    }\n  },\n  privateImport: function privateImport(key, data, options) {\n    options = options || {};\n    var buffer;\n\n    if (options.type !== 'der') {\n      if (Buffer.isBuffer(data)) {\n        data = data.toString('utf8');\n      }\n\n      if (_.isString(data)) {\n        var pem = utils.trimSurroundingText(data, PRIVATE_OPENING_BOUNDARY, PRIVATE_CLOSING_BOUNDARY).replace(/\\s+|\\n\\r|\\n|\\r$/gm, '');\n        buffer = Buffer.from(pem, 'base64');\n      } else {\n        throw Error('Unsupported key format');\n      }\n    } else if (Buffer.isBuffer(data)) {\n      buffer = data;\n    } else {\n      throw Error('Unsupported key format');\n    }\n\n    var reader = new ber.Reader(buffer);\n    reader.readSequence();\n    reader.readString(2, true); // just zero\n\n    key.setPrivate(reader.readString(2, true), // modulus\n    reader.readString(2, true), // publicExponent\n    reader.readString(2, true), // privateExponent\n    reader.readString(2, true), // prime1\n    reader.readString(2, true), // prime2\n    reader.readString(2, true), // exponent1 -- d mod (p1)\n    reader.readString(2, true), // exponent2 -- d mod (q-1)\n    reader.readString(2, true) // coefficient -- (inverse of q) mod p\n    );\n  },\n  publicExport: function publicExport(key, options) {\n    options = options || {};\n    var n = key.n.toBuffer();\n    var length = n.length + 512; // magic\n\n    var bodyWriter = new ber.Writer({\n      size: length\n    });\n    bodyWriter.startSequence();\n    bodyWriter.writeBuffer(n, 2);\n    bodyWriter.writeInt(key.e);\n    bodyWriter.endSequence();\n\n    if (options.type === 'der') {\n      return bodyWriter.buffer;\n    } else {\n      return PUBLIC_OPENING_BOUNDARY + '\\n' + utils.linebrk(bodyWriter.buffer.toString('base64'), 64) + '\\n' + PUBLIC_CLOSING_BOUNDARY;\n    }\n  },\n  publicImport: function publicImport(key, data, options) {\n    options = options || {};\n    var buffer;\n\n    if (options.type !== 'der') {\n      if (Buffer.isBuffer(data)) {\n        data = data.toString('utf8');\n      }\n\n      if (_.isString(data)) {\n        var pem = utils.trimSurroundingText(data, PUBLIC_OPENING_BOUNDARY, PUBLIC_CLOSING_BOUNDARY).replace(/\\s+|\\n\\r|\\n|\\r$/gm, '');\n        buffer = Buffer.from(pem, 'base64');\n      }\n    } else if (Buffer.isBuffer(data)) {\n      buffer = data;\n    } else {\n      throw Error('Unsupported key format');\n    }\n\n    var body = new ber.Reader(buffer);\n    body.readSequence();\n    key.setPublic(body.readString(0x02, true), // modulus\n    body.readString(0x02, true) // publicExponent\n    );\n  },\n\n  /**\n   * Trying autodetect and import key\n   * @param key\n   * @param data\n   */\n  autoImport: function autoImport(key, data) {\n    // [\\S\\s]* matches zero or more of any character\n    if (/^[\\S\\s]*-----BEGIN RSA PRIVATE KEY-----\\s*(?=(([A-Za-z0-9+/=]+\\s*)+))\\1-----END RSA PRIVATE KEY-----[\\S\\s]*$/g.test(data)) {\n      module.exports.privateImport(key, data);\n      return true;\n    }\n\n    if (/^[\\S\\s]*-----BEGIN RSA PUBLIC KEY-----\\s*(?=(([A-Za-z0-9+/=]+\\s*)+))\\1-----END RSA PUBLIC KEY-----[\\S\\s]*$/g.test(data)) {\n      module.exports.publicImport(key, data);\n      return true;\n    }\n\n    return false;\n  }\n};","map":null,"metadata":{},"sourceType":"script"}