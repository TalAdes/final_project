{"ast":null,"code":"/**\n * PKCS_OAEP signature scheme\n */\nvar BigInteger = require('../libs/jsbn');\n\nvar crypt = require('crypto');\n\nmodule.exports = {\n  isEncryption: true,\n  isSignature: false\n};\nmodule.exports.digestLength = {\n  md4: 16,\n  md5: 16,\n  ripemd160: 20,\n  rmd160: 20,\n  sha1: 20,\n  sha224: 28,\n  sha256: 32,\n  sha384: 48,\n  sha512: 64\n};\nvar DEFAULT_HASH_FUNCTION = 'sha1';\n/*\n * OAEP Mask Generation Function 1\n * Generates a buffer full of pseudorandom bytes given seed and maskLength.\n * Giving the same seed, maskLength, and hashFunction will result in the same exact byte values in the buffer.\n *\n * https://tools.ietf.org/html/rfc3447#appendix-B.2.1\n *\n * Parameters:\n * seed\t\t\t[Buffer]\tThe pseudo random seed for this function\n * maskLength\t[int]\t\tThe length of the output\n * hashFunction\t[String]\tThe hashing function to use. Will accept any valid crypto hash. Default \"sha1\"\n *\t\tSupports \"sha1\" and \"sha256\".\n *\t\tTo add another algorythm the algorythem must be accepted by crypto.createHash, and then the length of the output of the hash function (the digest) must be added to the digestLength object below.\n *\t\tMost RSA implementations will be expecting sha1\n */\n\nmodule.exports.eme_oaep_mgf1 = function (seed, maskLength, hashFunction) {\n  hashFunction = hashFunction || DEFAULT_HASH_FUNCTION;\n  var hLen = module.exports.digestLength[hashFunction];\n  var count = Math.ceil(maskLength / hLen);\n  var T = Buffer.alloc(hLen * count);\n  var c = Buffer.alloc(4);\n\n  for (var i = 0; i < count; ++i) {\n    var hash = crypt.createHash(hashFunction);\n    hash.update(seed);\n    c.writeUInt32BE(i, 0);\n    hash.update(c);\n    hash.digest().copy(T, i * hLen);\n  }\n\n  return T.slice(0, maskLength);\n};\n\nmodule.exports.makeScheme = function (key, options) {\n  function Scheme(key, options) {\n    this.key = key;\n    this.options = options;\n  }\n\n  Scheme.prototype.maxMessageLength = function () {\n    return this.key.encryptedDataLength - 2 * module.exports.digestLength[this.options.encryptionSchemeOptions.hash || DEFAULT_HASH_FUNCTION] - 2;\n  };\n  /**\n   * Pad input\n   * alg: PKCS1_OAEP\n   *\n   * https://tools.ietf.org/html/rfc3447#section-7.1.1\n   */\n\n\n  Scheme.prototype.encPad = function (buffer) {\n    var hash = this.options.encryptionSchemeOptions.hash || DEFAULT_HASH_FUNCTION;\n    var mgf = this.options.encryptionSchemeOptions.mgf || module.exports.eme_oaep_mgf1;\n    var label = this.options.encryptionSchemeOptions.label || Buffer.alloc(0);\n    var emLen = this.key.encryptedDataLength;\n    var hLen = module.exports.digestLength[hash]; // Make sure we can put message into an encoded message of emLen bytes\n\n    if (buffer.length > emLen - 2 * hLen - 2) {\n      throw new Error(\"Message is too long to encode into an encoded message with a length of \" + emLen + \" bytes, increase\" + \"emLen to fix this error (minimum value for given parameters and options: \" + (emLen - 2 * hLen - 2) + \")\");\n    }\n\n    var lHash = crypt.createHash(hash);\n    lHash.update(label);\n    lHash = lHash.digest();\n    var PS = Buffer.alloc(emLen - buffer.length - 2 * hLen - 1); // Padding \"String\"\n\n    PS.fill(0); // Fill the buffer with octets of 0\n\n    PS[PS.length - 1] = 1;\n    var DB = Buffer.concat([lHash, PS, buffer]);\n    var seed = crypt.randomBytes(hLen); // mask = dbMask\n\n    var mask = mgf(seed, DB.length, hash); // XOR DB and dbMask together.\n\n    for (var i = 0; i < DB.length; i++) {\n      DB[i] ^= mask[i];\n    } // DB = maskedDB\n    // mask = seedMask\n\n\n    mask = mgf(DB, hLen, hash); // XOR seed and seedMask together.\n\n    for (i = 0; i < seed.length; i++) {\n      seed[i] ^= mask[i];\n    } // seed = maskedSeed\n\n\n    var em = Buffer.alloc(1 + seed.length + DB.length);\n    em[0] = 0;\n    seed.copy(em, 1);\n    DB.copy(em, 1 + seed.length);\n    return em;\n  };\n  /**\n   * Unpad input\n   * alg: PKCS1_OAEP\n   *\n   * Note: This method works within the buffer given and modifies the values. It also returns a slice of the EM as the return Message.\n   * If the implementation requires that the EM parameter be unmodified then the implementation should pass in a clone of the EM buffer.\n   *\n   * https://tools.ietf.org/html/rfc3447#section-7.1.2\n   */\n\n\n  Scheme.prototype.encUnPad = function (buffer) {\n    var hash = this.options.encryptionSchemeOptions.hash || DEFAULT_HASH_FUNCTION;\n    var mgf = this.options.encryptionSchemeOptions.mgf || module.exports.eme_oaep_mgf1;\n    var label = this.options.encryptionSchemeOptions.label || Buffer.alloc(0);\n    var hLen = module.exports.digestLength[hash]; // Check to see if buffer is a properly encoded OAEP message\n\n    if (buffer.length < 2 * hLen + 2) {\n      throw new Error(\"Error decoding message, the supplied message is not long enough to be a valid OAEP encoded message\");\n    }\n\n    var seed = buffer.slice(1, hLen + 1); // seed = maskedSeed\n\n    var DB = buffer.slice(1 + hLen); // DB = maskedDB\n\n    var mask = mgf(DB, hLen, hash); // seedMask\n    // XOR maskedSeed and seedMask together to get the original seed.\n\n    for (var i = 0; i < seed.length; i++) {\n      seed[i] ^= mask[i];\n    }\n\n    mask = mgf(seed, DB.length, hash); // dbMask\n    // XOR DB and dbMask together to get the original data block.\n\n    for (i = 0; i < DB.length; i++) {\n      DB[i] ^= mask[i];\n    }\n\n    var lHash = crypt.createHash(hash);\n    lHash.update(label);\n    lHash = lHash.digest();\n    var lHashEM = DB.slice(0, hLen);\n\n    if (lHashEM.toString(\"hex\") != lHash.toString(\"hex\")) {\n      throw new Error(\"Error decoding message, the lHash calculated from the label provided and the lHash in the encrypted data do not match.\");\n    } // Filter out padding\n\n\n    i = hLen;\n\n    while (DB[i++] === 0 && i < DB.length) {\n      ;\n    }\n\n    if (DB[i - 1] != 1) {\n      throw new Error(\"Error decoding message, there is no padding message separator byte\");\n    }\n\n    return DB.slice(i); // Message\n  };\n\n  return new Scheme(key, options);\n};","map":null,"metadata":{},"sourceType":"script"}