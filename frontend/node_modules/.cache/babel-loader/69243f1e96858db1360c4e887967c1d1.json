{"ast":null,"code":"/**\n * PSS signature scheme\n */\nvar BigInteger = require('../libs/jsbn');\n\nvar crypt = require('crypto');\n\nmodule.exports = {\n  isEncryption: false,\n  isSignature: true\n};\nvar DEFAULT_HASH_FUNCTION = 'sha1';\nvar DEFAULT_SALT_LENGTH = 20;\n\nmodule.exports.makeScheme = function (key, options) {\n  var OAEP = require('./schemes').pkcs1_oaep;\n  /**\n   * @param key\n   * @param options\n   * options    [Object]    An object that contains the following keys that specify certain options for encoding.\n   *  └>signingSchemeOptions\n   *     ├>hash    [String]    Hash function to use when encoding and generating masks. Must be a string accepted by node's crypto.createHash function. (default = \"sha1\")\n   *     ├>mgf    [function]    The mask generation function to use when encoding. (default = mgf1SHA1)\n   *     └>sLen    [uint]        The length of the salt to generate. (default = 20)\n   * @constructor\n   */\n\n\n  function Scheme(key, options) {\n    this.key = key;\n    this.options = options;\n  }\n\n  Scheme.prototype.sign = function (buffer) {\n    var mHash = crypt.createHash(this.options.signingSchemeOptions.hash || DEFAULT_HASH_FUNCTION);\n    mHash.update(buffer);\n    var encoded = this.emsa_pss_encode(mHash.digest(), this.key.keySize - 1);\n    return this.key.$doPrivate(new BigInteger(encoded)).toBuffer(this.key.encryptedDataLength);\n  };\n\n  Scheme.prototype.verify = function (buffer, signature, signature_encoding) {\n    if (signature_encoding) {\n      signature = Buffer.from(signature, signature_encoding);\n    }\n\n    signature = new BigInteger(signature);\n    var emLen = Math.ceil((this.key.keySize - 1) / 8);\n    var m = this.key.$doPublic(signature).toBuffer(emLen);\n    var mHash = crypt.createHash(this.options.signingSchemeOptions.hash || DEFAULT_HASH_FUNCTION);\n    mHash.update(buffer);\n    return this.emsa_pss_verify(mHash.digest(), m, this.key.keySize - 1);\n  };\n  /*\n   * https://tools.ietf.org/html/rfc3447#section-9.1.1\n   *\n   * mHash\t[Buffer]\tHashed message to encode\n   * emBits\t[uint]\t\tMaximum length of output in bits. Must be at least 8hLen + 8sLen + 9 (hLen = Hash digest length in bytes | sLen = length of salt in bytes)\n   * @returns {Buffer} The encoded message\n   */\n\n\n  Scheme.prototype.emsa_pss_encode = function (mHash, emBits) {\n    var hash = this.options.signingSchemeOptions.hash || DEFAULT_HASH_FUNCTION;\n    var mgf = this.options.signingSchemeOptions.mgf || OAEP.eme_oaep_mgf1;\n    var sLen = this.options.signingSchemeOptions.saltLength || DEFAULT_SALT_LENGTH;\n    var hLen = OAEP.digestLength[hash];\n    var emLen = Math.ceil(emBits / 8);\n\n    if (emLen < hLen + sLen + 2) {\n      throw new Error(\"Output length passed to emBits(\" + emBits + \") is too small for the options \" + \"specified(\" + hash + \", \" + sLen + \"). To fix this issue increase the value of emBits. (minimum size: \" + (8 * hLen + 8 * sLen + 9) + \")\");\n    }\n\n    var salt = crypt.randomBytes(sLen);\n    var Mapostrophe = Buffer.alloc(8 + hLen + sLen);\n    Mapostrophe.fill(0, 0, 8);\n    mHash.copy(Mapostrophe, 8);\n    salt.copy(Mapostrophe, 8 + mHash.length);\n    var H = crypt.createHash(hash);\n    H.update(Mapostrophe);\n    H = H.digest();\n    var PS = Buffer.alloc(emLen - salt.length - hLen - 2);\n    PS.fill(0);\n    var DB = Buffer.alloc(PS.length + 1 + salt.length);\n    PS.copy(DB);\n    DB[PS.length] = 0x01;\n    salt.copy(DB, PS.length + 1);\n    var dbMask = mgf(H, DB.length, hash); // XOR DB and dbMask together\n\n    var maskedDB = Buffer.alloc(DB.length);\n\n    for (var i = 0; i < dbMask.length; i++) {\n      maskedDB[i] = DB[i] ^ dbMask[i];\n    }\n\n    var bits = 8 * emLen - emBits;\n    var mask = 255 ^ 255 >> 8 - bits << 8 - bits;\n    maskedDB[0] = maskedDB[0] & mask;\n    var EM = Buffer.alloc(maskedDB.length + H.length + 1);\n    maskedDB.copy(EM, 0);\n    H.copy(EM, maskedDB.length);\n    EM[EM.length - 1] = 0xbc;\n    return EM;\n  };\n  /*\n   * https://tools.ietf.org/html/rfc3447#section-9.1.2\n   *\n   * mHash\t[Buffer]\tHashed message\n   * EM\t\t[Buffer]\tSignature\n   * emBits\t[uint]\t\tLength of EM in bits. Must be at least 8hLen + 8sLen + 9 to be a valid signature. (hLen = Hash digest length in bytes | sLen = length of salt in bytes)\n   * @returns {Boolean} True if signature(EM) matches message(M)\n   */\n\n\n  Scheme.prototype.emsa_pss_verify = function (mHash, EM, emBits) {\n    var hash = this.options.signingSchemeOptions.hash || DEFAULT_HASH_FUNCTION;\n    var mgf = this.options.signingSchemeOptions.mgf || OAEP.eme_oaep_mgf1;\n    var sLen = this.options.signingSchemeOptions.saltLength || DEFAULT_SALT_LENGTH;\n    var hLen = OAEP.digestLength[hash];\n    var emLen = Math.ceil(emBits / 8);\n\n    if (emLen < hLen + sLen + 2 || EM[EM.length - 1] != 0xbc) {\n      return false;\n    }\n\n    var DB = Buffer.alloc(emLen - hLen - 1);\n    EM.copy(DB, 0, 0, emLen - hLen - 1);\n    var mask = 0;\n\n    for (var i = 0, bits = 8 * emLen - emBits; i < bits; i++) {\n      mask |= 1 << 7 - i;\n    }\n\n    if ((DB[0] & mask) !== 0) {\n      return false;\n    }\n\n    var H = EM.slice(emLen - hLen - 1, emLen - 1);\n    var dbMask = mgf(H, DB.length, hash); // Unmask DB\n\n    for (i = 0; i < DB.length; i++) {\n      DB[i] ^= dbMask[i];\n    }\n\n    bits = 8 * emLen - emBits;\n    mask = 255 ^ 255 >> 8 - bits << 8 - bits;\n    DB[0] = DB[0] & mask; // Filter out padding\n\n    for (i = 0; DB[i] === 0 && i < DB.length; i++) {\n      ;\n    }\n\n    if (DB[i] != 1) {\n      return false;\n    }\n\n    var salt = DB.slice(DB.length - sLen);\n    var Mapostrophe = Buffer.alloc(8 + hLen + sLen);\n    Mapostrophe.fill(0, 0, 8);\n    mHash.copy(Mapostrophe, 8);\n    salt.copy(Mapostrophe, 8 + mHash.length);\n    var Hapostrophe = crypt.createHash(hash);\n    Hapostrophe.update(Mapostrophe);\n    Hapostrophe = Hapostrophe.digest();\n    return H.toString(\"hex\") === Hapostrophe.toString(\"hex\");\n  };\n\n  return new Scheme(key, options);\n};","map":null,"metadata":{},"sourceType":"script"}