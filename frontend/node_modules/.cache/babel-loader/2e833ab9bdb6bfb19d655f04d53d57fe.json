{"ast":null,"code":"/*\n * RSA Encryption / Decryption with PKCS1 v2 Padding.\n * \n * Copyright (c) 2003-2005  Tom Wu\n * All Rights Reserved.\n *\n * Permission is hereby granted, free of charge, to any person obtaining\n * a copy of this software and associated documentation files (the\n * \"Software\"), to deal in the Software without restriction, including\n * without limitation the rights to use, copy, modify, merge, publish,\n * distribute, sublicense, and/or sell copies of the Software, and to\n * permit persons to whom the Software is furnished to do so, subject to\n * the following conditions:\n *\n * The above copyright notice and this permission notice shall be\n * included in all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS-IS\" AND WITHOUT WARRANTY OF ANY KIND, \n * EXPRESS, IMPLIED OR OTHERWISE, INCLUDING WITHOUT LIMITATION, ANY \n * WARRANTY OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.  \n *\n * IN NO EVENT SHALL TOM WU BE LIABLE FOR ANY SPECIAL, INCIDENTAL,\n * INDIRECT OR CONSEQUENTIAL DAMAGES OF ANY KIND, OR ANY DAMAGES WHATSOEVER\n * RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER OR NOT ADVISED OF\n * THE POSSIBILITY OF DAMAGE, AND ON ANY THEORY OF LIABILITY, ARISING OUT\n * OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n *\n * In addition, the following condition applies:\n *\n * All redistributions must retain an intact copy of this copyright notice\n * and disclaimer.\n */\n\n/*\n * Node.js adaptation\n * long message support implementation\n * signing/verifying\n *\n * 2014 rzcoder\n */\nvar _ = require('../utils')._;\n\nvar crypt = require('crypto');\n\nvar BigInteger = require('./jsbn.js');\n\nvar utils = require('../utils.js');\n\nvar schemes = require('../schemes/schemes.js');\n\nvar encryptEngines = require('../encryptEngines/encryptEngines.js');\n\nexports.BigInteger = BigInteger;\n\nmodule.exports.Key = function () {\n  /**\n   * RSA key constructor\n   *\n   * n - modulus\n   * e - publicExponent\n   * d - privateExponent\n   * p - prime1\n   * q - prime2\n   * dmp1 - exponent1 -- d mod (p1)\n   * dmq1 - exponent2 -- d mod (q-1)\n   * coeff - coefficient -- (inverse of q) mod p\n   */\n  function RSAKey() {\n    this.n = null;\n    this.e = 0;\n    this.d = null;\n    this.p = null;\n    this.q = null;\n    this.dmp1 = null;\n    this.dmq1 = null;\n    this.coeff = null;\n  }\n\n  RSAKey.prototype.setOptions = function (options) {\n    var signingSchemeProvider = schemes[options.signingScheme];\n    var encryptionSchemeProvider = schemes[options.encryptionScheme];\n\n    if (signingSchemeProvider === encryptionSchemeProvider) {\n      this.signingScheme = this.encryptionScheme = encryptionSchemeProvider.makeScheme(this, options);\n    } else {\n      this.encryptionScheme = encryptionSchemeProvider.makeScheme(this, options);\n      this.signingScheme = signingSchemeProvider.makeScheme(this, options);\n    }\n\n    this.encryptEngine = encryptEngines.getEngine(this, options);\n  };\n  /**\n   * Generate a new random private key B bits long, using public expt E\n   * @param B\n   * @param E\n   */\n\n\n  RSAKey.prototype.generate = function (B, E) {\n    var qs = B >> 1;\n    this.e = parseInt(E, 16);\n    var ee = new BigInteger(E, 16);\n\n    while (true) {\n      while (true) {\n        this.p = new BigInteger(B - qs, 1);\n        if (this.p.subtract(BigInteger.ONE).gcd(ee).compareTo(BigInteger.ONE) === 0 && this.p.isProbablePrime(10)) break;\n      }\n\n      while (true) {\n        this.q = new BigInteger(qs, 1);\n        if (this.q.subtract(BigInteger.ONE).gcd(ee).compareTo(BigInteger.ONE) === 0 && this.q.isProbablePrime(10)) break;\n      }\n\n      if (this.p.compareTo(this.q) <= 0) {\n        var t = this.p;\n        this.p = this.q;\n        this.q = t;\n      }\n\n      var p1 = this.p.subtract(BigInteger.ONE);\n      var q1 = this.q.subtract(BigInteger.ONE);\n      var phi = p1.multiply(q1);\n\n      if (phi.gcd(ee).compareTo(BigInteger.ONE) === 0) {\n        this.n = this.p.multiply(this.q);\n\n        if (this.n.bitLength() < B) {\n          continue;\n        }\n\n        this.d = ee.modInverse(phi);\n        this.dmp1 = this.d.mod(p1);\n        this.dmq1 = this.d.mod(q1);\n        this.coeff = this.q.modInverse(this.p);\n        break;\n      }\n    }\n\n    this.$$recalculateCache();\n  };\n  /**\n   * Set the private key fields N, e, d and CRT params from buffers\n   *\n   * @param N\n   * @param E\n   * @param D\n   * @param P\n   * @param Q\n   * @param DP\n   * @param DQ\n   * @param C\n   */\n\n\n  RSAKey.prototype.setPrivate = function (N, E, D, P, Q, DP, DQ, C) {\n    if (N && E && D && N.length > 0 && (_.isNumber(E) || E.length > 0) && D.length > 0) {\n      this.n = new BigInteger(N);\n      this.e = _.isNumber(E) ? E : utils.get32IntFromBuffer(E, 0);\n      this.d = new BigInteger(D);\n\n      if (P && Q && DP && DQ && C) {\n        this.p = new BigInteger(P);\n        this.q = new BigInteger(Q);\n        this.dmp1 = new BigInteger(DP);\n        this.dmq1 = new BigInteger(DQ);\n        this.coeff = new BigInteger(C);\n      } else {// TODO: re-calculate any missing CRT params\n      }\n\n      this.$$recalculateCache();\n    } else {\n      throw Error(\"Invalid RSA private key\");\n    }\n  };\n  /**\n   * Set the public key fields N and e from hex strings\n   * @param N\n   * @param E\n   */\n\n\n  RSAKey.prototype.setPublic = function (N, E) {\n    if (N && E && N.length > 0 && (_.isNumber(E) || E.length > 0)) {\n      this.n = new BigInteger(N);\n      this.e = _.isNumber(E) ? E : utils.get32IntFromBuffer(E, 0);\n      this.$$recalculateCache();\n    } else {\n      throw Error(\"Invalid RSA public key\");\n    }\n  };\n  /**\n   * private\n   * Perform raw private operation on \"x\": return x^d (mod n)\n   *\n   * @param x\n   * @returns {*}\n   */\n\n\n  RSAKey.prototype.$doPrivate = function (x) {\n    if (this.p || this.q) {\n      return x.modPow(this.d, this.n);\n    } // TODO: re-calculate any missing CRT params\n\n\n    var xp = x.mod(this.p).modPow(this.dmp1, this.p);\n    var xq = x.mod(this.q).modPow(this.dmq1, this.q);\n\n    while (xp.compareTo(xq) < 0) {\n      xp = xp.add(this.p);\n    }\n\n    return xp.subtract(xq).multiply(this.coeff).mod(this.p).multiply(this.q).add(xq);\n  };\n  /**\n   * private\n   * Perform raw public operation on \"x\": return x^e (mod n)\n   *\n   * @param x\n   * @returns {*}\n   */\n\n\n  RSAKey.prototype.$doPublic = function (x) {\n    return x.modPowInt(this.e, this.n);\n  };\n  /**\n   * Return the PKCS#1 RSA encryption of buffer\n   * @param buffer {Buffer}\n   * @returns {Buffer}\n   */\n\n\n  RSAKey.prototype.encrypt = function (buffer, usePrivate) {\n    var buffers = [];\n    var results = [];\n    var bufferSize = buffer.length;\n    var buffersCount = Math.ceil(bufferSize / this.maxMessageLength) || 1; // total buffers count for encrypt\n\n    var dividedSize = Math.ceil(bufferSize / buffersCount || 1); // each buffer size\n\n    if (buffersCount == 1) {\n      buffers.push(buffer);\n    } else {\n      for (var bufNum = 0; bufNum < buffersCount; bufNum++) {\n        buffers.push(buffer.slice(bufNum * dividedSize, (bufNum + 1) * dividedSize));\n      }\n    }\n\n    for (var i = 0; i < buffers.length; i++) {\n      results.push(this.encryptEngine.encrypt(buffers[i], usePrivate));\n    }\n\n    return Buffer.concat(results);\n  };\n  /**\n   * Return the PKCS#1 RSA decryption of buffer\n   * @param buffer {Buffer}\n   * @returns {Buffer}\n   */\n\n\n  RSAKey.prototype.decrypt = function (buffer, usePublic) {\n    if (buffer.length % this.encryptedDataLength > 0) {\n      throw Error('Incorrect data or key');\n    }\n\n    var result = [];\n    var offset = 0;\n    var length = 0;\n    var buffersCount = buffer.length / this.encryptedDataLength;\n\n    for (var i = 0; i < buffersCount; i++) {\n      offset = i * this.encryptedDataLength;\n      length = offset + this.encryptedDataLength;\n      result.push(this.encryptEngine.decrypt(buffer.slice(offset, Math.min(length, buffer.length)), usePublic));\n    }\n\n    return Buffer.concat(result);\n  };\n\n  RSAKey.prototype.sign = function (buffer) {\n    return this.signingScheme.sign.apply(this.signingScheme, arguments);\n  };\n\n  RSAKey.prototype.verify = function (buffer, signature, signature_encoding) {\n    return this.signingScheme.verify.apply(this.signingScheme, arguments);\n  };\n  /**\n   * Check if key pair contains private key\n   */\n\n\n  RSAKey.prototype.isPrivate = function () {\n    return this.n && this.e && this.d || false;\n  };\n  /**\n   * Check if key pair contains public key\n   * @param strict {boolean} - public key only, return false if have private exponent\n   */\n\n\n  RSAKey.prototype.isPublic = function (strict) {\n    return this.n && this.e && !(strict && this.d) || false;\n  };\n\n  Object.defineProperty(RSAKey.prototype, 'keySize', {\n    get: function get() {\n      return this.cache.keyBitLength;\n    }\n  });\n  Object.defineProperty(RSAKey.prototype, 'encryptedDataLength', {\n    get: function get() {\n      return this.cache.keyByteLength;\n    }\n  });\n  Object.defineProperty(RSAKey.prototype, 'maxMessageLength', {\n    get: function get() {\n      return this.encryptionScheme.maxMessageLength();\n    }\n  });\n  /**\n   * Caching key data\n   */\n\n  RSAKey.prototype.$$recalculateCache = function () {\n    this.cache = this.cache || {}; // Bit & byte length\n\n    this.cache.keyBitLength = this.n.bitLength();\n    this.cache.keyByteLength = this.cache.keyBitLength + 6 >> 3;\n  };\n\n  return RSAKey;\n}();","map":null,"metadata":{},"sourceType":"script"}